//
// Copyright (c) Brian Hernandez. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
//

using UnityEngine;

namespace MFlight.Demo
{ 
    /// <summary>
    /// This is a very demo-ey example of how to interpret the input generated by the
    /// MouseFlightController. The plane flies towards the MouseAimPos automatically in
    /// a similar fashion to how War Thunder's Instructor does it. There are also
    /// keyboard overrides for flight control. It's not perfect, but it works well enough
    /// for an example.
    /// </summary>
    [RequireComponent(typeof(Rigidbody))]
    public class Plane : MonoBehaviour
    {
        [Header("Physics")]
        [Tooltip("Force to push plane forwards with")] public float minThrust = 100f;
        [Tooltip("Throttle")] public float maximumThrust = 500f;
        [Tooltip("Initial speed for plane when level starts")] public float initialSpeed = 1000f;

        [Header("Input")]
        [SerializeField] [Range(-1f, 1f)] private float pitch = 0f;
        [SerializeField] [Range(-1f, 1f)] private float yaw = 0f;
        [SerializeField] [Range(-1f, 1f)] private float roll = 0f;
        [SerializeField] [Range(0f, 1f)] private float throttle = 0f;
        [SerializeField] private bool _isInStall;
        [SerializeField] private Vector3 _stallRotationPower;

        [Header("Drag")]
        [SerializeField] private AnimationCurve dragForward;
        [SerializeField] private AnimationCurve dragBack;
        [SerializeField] private AnimationCurve dragLeft;
        [SerializeField] private AnimationCurve dragRight;
        [SerializeField] private AnimationCurve dragTop;
        [SerializeField] private AnimationCurve dragBottom;
        [SerializeField] private Vector3 angularDragScale;
        [SerializeField] private float airbrakeDrag;
        [SerializeField] private bool airbreakDeployed = false;

        [Header("Lift")]
        [SerializeField] private float liftPower;
        [SerializeField] private AnimationCurve liftAOACurve;
        [SerializeField] private float inducedDrag;
        [SerializeField] private AnimationCurve inducedDragCurve;
        [SerializeField] private float rudderPower;
        [SerializeField] private AnimationCurve rudderAOACurve;
        [SerializeField] private AnimationCurve rudderInducedDragCurve;
        [SerializeField] private float flapsLiftPower;
        [SerializeField] private float flapsAOABias;
        [SerializeField] private float flapsDrag;
        [SerializeField] private bool flapsDeployed = false;

        [Header("Steering")]
        [SerializeField] private Vector3 turnSpeed;
        [SerializeField] private Vector3 turnAcceleration;
        [SerializeField] private AnimationCurve steeringCurve;

        [Header("GLimit")]
        [SerializeField] private bool enableGLimit = false;
        [SerializeField] private float gLimit;
        [SerializeField] private float gLimitPitch;

        public Vector3 Velocity { get; private set; }
        public Vector3 Drag { get; private set; }
        public Vector3 AngularDrag { get; private set; }
        public Vector3 LocalVelocity { get; private set; }
        public Vector3 LocalAngularVelocity { get; private set; }
        public Vector3 LocalGForce { get; private set; }
        public Rigidbody Rigidbody { get; private set; }
        public float AngleOfAttack { get; private set; }
        public float AngleOfAttackYaw { get; private set; }
        public Vector3 EffectiveInput { get; private set; }


        public float Pitch { set { pitch = Mathf.Clamp(value, -1f, 1f); } get { return pitch; } }
        public float Yaw { set { yaw = Mathf.Clamp(value, -1f, 1f); } get { return yaw; } }
        public float Roll { set { roll = Mathf.Clamp(value, -1f, 1f); } get { return roll; } }
        public float Throttle { set { throttle = Mathf.Clamp(value, 0f, 1f); } get { return throttle; } }
        public bool AirBreakDeployed { set { airbreakDeployed = value; } get { return airbreakDeployed; } }
        public bool FlapsDeployed { set { flapsDeployed = value; } get { return flapsDeployed; } }
        public bool IsInStall { set { _isInStall = value; } get { return _isInStall; } }
        public float StallYaw { get { return _stallRotationPower.x; } }
        public float StallPitch { get { return _stallRotationPower.y; } }
        public float StallRoll { get { return _stallRotationPower.z; } }

        private Vector3 lastVelocity;

        private void Start()
        {
            Rigidbody = GetComponent<Rigidbody>();
            Rigidbody.velocity = Rigidbody.rotation * new Vector3(0, 0, initialSpeed);
        }

        private void CalculateState()
        {
            var invRotation = Quaternion.Inverse(Rigidbody.rotation);
            Velocity = Rigidbody.velocity;
            LocalVelocity = invRotation * Velocity;  //transform world velocity into local space
            LocalAngularVelocity = invRotation * Rigidbody.angularVelocity;  //transform into local space

            CalculateAngleOfAttack();
        }
        void CalculateAngleOfAttack()
        {
            if (LocalVelocity.sqrMagnitude < 0.1f)
            {
                AngleOfAttack = 0;
                AngleOfAttackYaw = 0;
                return;
            }

            AngleOfAttack = Mathf.Atan2(-LocalVelocity.y, LocalVelocity.z);
            AngleOfAttackYaw = Mathf.Atan2(LocalVelocity.x, LocalVelocity.z);
        }

        private void UpdateDrag()
        {
            var lv = LocalVelocity;
            var lv2 = lv.sqrMagnitude;  //velocity squared

            float airbrakeDrag = AirBreakDeployed ? this.airbrakeDrag : 0;
            float flapsDrag = FlapsDeployed ? this.flapsDrag : 0;

            //calculate coefficient of drag depending on direction on velocity
            var coefficient = Utilities.Scale6(
                lv.normalized,
                dragRight.Evaluate(Mathf.Abs(lv.x)), dragLeft.Evaluate(Mathf.Abs(lv.x)),
                dragTop.Evaluate(Mathf.Abs(lv.y)), dragBottom.Evaluate(Mathf.Abs(lv.y)),
                dragForward.Evaluate(Mathf.Abs(lv.z)) + airbrakeDrag + flapsDrag,   //include extra drag for forward coefficient
                dragBack.Evaluate(Mathf.Abs(lv.z))
            );

            Drag = coefficient.magnitude * lv2 * -lv.normalized;    //drag is opposite direction of velocity
            Rigidbody.AddRelativeForce(Drag);
        }

        void UpdateAngularDrag()
        {
            var av = LocalAngularVelocity;
            AngularDrag = av.sqrMagnitude * -av.normalized;    //squared, opposite direction of angular velocity
            Rigidbody.AddRelativeTorque(Vector3.Scale(AngularDrag, angularDragScale), ForceMode.Acceleration);  //ignore rigidbody mass
        }

        Vector3 CalculateLift(float angleOfAttack, Vector3 rightAxis, float liftPower, AnimationCurve aoaCurve, AnimationCurve inducedDragCurve)
        {
            var liftVelocity = Vector3.ProjectOnPlane(LocalVelocity, rightAxis);    //project velocity onto YZ plane
            var v2 = liftVelocity.sqrMagnitude;                                     //square of velocity

            //lift = velocity^2 * coefficient * liftPower
            //coefficient varies with AOA
            var liftCoefficient = aoaCurve.Evaluate(angleOfAttack * Mathf.Rad2Deg);
            var liftForce = v2 * liftCoefficient * liftPower;

            //lift is perpendicular to velocity
            var liftDirection = Vector3.Cross(liftVelocity.normalized, rightAxis);
            var lift = liftDirection * liftForce;

            //induced drag varies with square of lift coefficient
            var dragForce = liftCoefficient * liftCoefficient;
            var dragDirection = -liftVelocity.normalized;
            var inducedDrag = dragDirection * v2 * dragForce * this.inducedDrag * inducedDragCurve.Evaluate(Mathf.Max(0, LocalVelocity.z));

            return lift + inducedDrag;
        }

        void UpdateLift()
        {
            if (LocalVelocity.sqrMagnitude < 1f) return;

            float flapsLiftPower = flapsDeployed ? this.flapsLiftPower : 0;
            float flapsAOABias = flapsDeployed ? this.flapsAOABias : 0;

            var liftForce = CalculateLift(
                AngleOfAttack + (flapsAOABias * Mathf.Deg2Rad), Vector3.right,
                liftPower + flapsLiftPower,
                liftAOACurve,
                inducedDragCurve
            );

            var yawForce = CalculateLift(AngleOfAttackYaw, Vector3.up, rudderPower, rudderAOACurve, rudderInducedDragCurve);

            Rigidbody.AddRelativeForce(liftForce);
            Rigidbody.AddRelativeForce(yawForce);
        }
        void UpdateThrust()
        {
            Rigidbody.AddRelativeForce((Throttle * maximumThrust) * Vector3.forward, ForceMode.Force);
        }
        float CalculateSteering(float dt, float angularVelocity, float targetVelocity, float acceleration)
        {
            var error = targetVelocity - angularVelocity;
            var accel = acceleration * dt;
            return Mathf.Clamp(error, -accel, accel);
        }

        void UpdateSteering(float dt)
        {
            var controlInput = new Vector3(pitch, yaw, roll);

            var speed = Mathf.Max(0, LocalVelocity.z);
            var steeringPower = _isInStall ? 1 : steeringCurve.Evaluate(speed);

            var gForceScaling = enableGLimit ? CalculateGLimiter(controlInput, turnSpeed * Mathf.Deg2Rad * steeringPower) : 1;

            var targetAV = Vector3.Scale(controlInput, new Vector3(turnSpeed.x, turnSpeed.y, -turnSpeed.z) * steeringPower * gForceScaling);
            var av = LocalAngularVelocity * Mathf.Rad2Deg;

            var correction = new Vector3(
                CalculateSteering(dt, av.x, targetAV.x, turnAcceleration.x * steeringPower),
                CalculateSteering(dt, av.y, targetAV.y, turnAcceleration.y * steeringPower),
                CalculateSteering(dt, av.z, targetAV.z, turnAcceleration.z * steeringPower)
            );

            Rigidbody.AddRelativeTorque(correction * Mathf.Deg2Rad, ForceMode.VelocityChange);    //ignore rigidbody mass

            var correctionInput = new Vector3(
                Mathf.Clamp((targetAV.x - av.x) / turnAcceleration.x, -1, 1),
                Mathf.Clamp((targetAV.y - av.y) / turnAcceleration.y, -1, 1),
                Mathf.Clamp((targetAV.z - av.z) / turnAcceleration.z, -1, 1)
            );

            var effectiveInput = (correctionInput + controlInput) * gForceScaling;

            EffectiveInput = new Vector3(
                Mathf.Clamp(effectiveInput.x, -1, 1),
                Mathf.Clamp(effectiveInput.y, -1, 1),
                Mathf.Clamp(effectiveInput.z, -1, 1)
            );
        }

        Vector3 CalculateGForce(Vector3 angularVelocity, Vector3 velocity)
        {
            //estiamte G Force from angular velocity and velocity
            //Velocity = AngularVelocity * Radius
            //G = Velocity^2 / R
            //G = (Velocity * AngularVelocity * Radius) / Radius
            //G = Velocity * AngularVelocity
            //G = V cross A
            return Vector3.Cross(angularVelocity, velocity);
        }

        Vector3 CalculateGForceLimit(Vector3 input)
        {
            return Utilities.Scale6(input,
                gLimit, gLimitPitch,    //pitch down, pitch up
                gLimit, gLimit,         //yaw
                gLimit, gLimit          //roll
            ) * 9.81f;
        }

        float CalculateGLimiter(Vector3 controlInput, Vector3 maxAngularVelocity)
        {
            if (controlInput.magnitude < 0.01f)
            {
                return 1;
            }

            //if the player gives input with magnitude less than 1, scale up their input so that magnitude == 1
            var maxInput = controlInput.normalized;

            var limit = CalculateGForceLimit(maxInput);
            var maxGForce = CalculateGForce(Vector3.Scale(maxInput, maxAngularVelocity), LocalVelocity);

            if (maxGForce.magnitude > limit.magnitude)
            {
                //example:
                //maxGForce = 16G, limit = 8G
                //so this is 8 / 16 or 0.5
                return limit.magnitude / maxGForce.magnitude;
            }

            return 1;
        }

        void CalculateGForce(float dt)
        {
            var invRotation = Quaternion.Inverse(Rigidbody.rotation);
            var acceleration = (Velocity - lastVelocity) / dt;
            LocalGForce = invRotation * acceleration;
            lastVelocity = Velocity;
        }

        private void FixedUpdate()
        {
            float dt = Time.fixedDeltaTime;
            CalculateState();
            CalculateGForce(dt);

            UpdateThrust();
            UpdateLift();
            UpdateSteering(dt);

            // Ultra simple flight where the plane just gets pushed forward and manipulated
            // with torques to turn.
            //rigid.AddRelativeTorque(new Vector3(turnTorque.x * pitch,
            //                                    turnTorque.y * yaw,
            //                                    -turnTorque.z * roll) * forceMult,
            //                        ForceMode.Force);

            UpdateDrag();
            UpdateAngularDrag();
        }
    }
}
