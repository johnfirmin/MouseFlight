//
// Copyright (c) Brian Hernandez. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
//

using Assets.MouseFlight.Demo.Scripts;
using UnityEngine;

namespace MFlight.Demo
{
    /// <summary>
    /// This is a very demo-ey example of how to interpret the input generated by the
    /// MouseFlightController. The plane flies towards the MouseAimPos automatically in
    /// a similar fashion to how War Thunder's Instructor does it. There are also
    /// keyboard overrides for flight control. It's not perfect, but it works well enough
    /// for an example.
    /// </summary>
    [RequireComponent(typeof(Rigidbody))]
    public class Plane : MonoBehaviour
    {
        [Header("Components")]
        [SerializeField] private MouseFlightController controller = null;

        [Header("Physics")]
        [Tooltip("Force to push plane forwards with")] public float minThrust = 100f;
        [Tooltip("Throttle")] public float maximumThrust = 500f;
        [Tooltip("Pitch, Yaw, Roll")] public Vector3 turnTorque = new Vector3(90f, 25f, 45f);
        [Tooltip("Multiplier for all forces")] public float forceMult = 1000f;

        [Header("Autopilot")]
        [Tooltip("Sensitivity for autopilot flight.")] public float sensitivity = 5f;
        [Tooltip("Angle at which airplane banks fully into target.")] public float aggressiveTurnAngle = 10f;

        [Header("Input")]
        [SerializeField] [Range(-1f, 1f)] private float pitch = 0f;
        [SerializeField] [Range(-1f, 1f)] private float yaw = 0f;
        [SerializeField] [Range(-1f, 1f)] private float roll = 0f;
        [SerializeField] [Range(0f, 1f)] private float throttle = 0f;

        [Header("Drag")]
        [SerializeField] private AnimationCurve dragForward;
        [SerializeField] private AnimationCurve dragBack;
        [SerializeField] private AnimationCurve dragLeft;
        [SerializeField] private AnimationCurve dragRight;
        [SerializeField] private AnimationCurve dragTop;
        [SerializeField] private AnimationCurve dragBottom;
        [SerializeField] private Vector3 angularDrag;

        [Header("Lift")]
        [SerializeField] private float liftPower;
        [SerializeField] private AnimationCurve liftAOACurve;
        [SerializeField] private float inducedDrag;
        [SerializeField] private AnimationCurve inducedDragCurve;
        [SerializeField] private float rudderPower;
        [SerializeField] private AnimationCurve rudderAOACurve;
        [SerializeField] private AnimationCurve rudderInducedDragCurve;
        [SerializeField] private float flapsLiftPower;
        [SerializeField] private float flapsAOABias;
        [SerializeField] private float flapsDrag;
        [SerializeField] private float flapsRetractSpeed;

        [Header("Steering")]
        [SerializeField] private Vector3 turnSpeed;
        [SerializeField] private Vector3 turnAcceleration;
        [SerializeField] private AnimationCurve steeringCurve;

        [Header("GLimit")]
        [SerializeField] private float gLimit;
        [SerializeField] private float gLimitPitch;

        public Vector3 Velocity { get; private set; }
        public Vector3 LocalVelocity { get; private set; }
        public Vector3 LocalAngularVelocity { get; private set; }
        public Rigidbody Rigidbody { get; private set; }
        public float AngleOfAttack { get; private set; }
        public float AngleOfAttackYaw { get; private set; }
        public Vector3 EffectiveInput { get; private set; }


        public float Pitch { set { pitch = Mathf.Clamp(value, -1f, 1f); } get { return pitch; } }
        public float Yaw { set { yaw = Mathf.Clamp(value, -1f, 1f); } get { return yaw; } }
        public float Roll { set { roll = Mathf.Clamp(value, -1f, 1f); } get { return roll; } }
        public float Throttle { set { throttle = Mathf.Clamp(value, 0f, 1f); } get { return throttle; } }

        private Rigidbody rigid;

        private bool rollOverride = false;
        private bool pitchOverride = false;
        private bool flapsDeployed = false;

        private void Start()
        {
            Rigidbody = GetComponent<Rigidbody>();
        }

        private void CalculateState()
        {
            var invRotation = Quaternion.Inverse(Rigidbody.rotation);
            Velocity = Rigidbody.velocity;
            LocalVelocity = invRotation * Velocity;  //transform world velocity into local space
            LocalAngularVelocity = invRotation * Rigidbody.angularVelocity;  //transform into local space

            CalculateAngleOfAttack();
        }
        void CalculateAngleOfAttack()
        {
            if (LocalVelocity.sqrMagnitude < 0.1f)
            {
                AngleOfAttack = 0;
                AngleOfAttackYaw = 0;
                return;
            }

            AngleOfAttack = Mathf.Atan2(-LocalVelocity.y, LocalVelocity.z);
            AngleOfAttackYaw = Mathf.Atan2(LocalVelocity.x, LocalVelocity.z);
        }

        private void UpdateDrag()
        {
            var lv = LocalVelocity;
            var lv2 = lv.sqrMagnitude;  //velocity squared

            float airbrakeDrag = 0;
            float flapsDrag = 0;

            //calculate coefficient of drag depending on direction on velocity
            var coefficient = Utilities.Scale6(
                lv.normalized,
                dragRight.Evaluate(Mathf.Abs(lv.x)), dragLeft.Evaluate(Mathf.Abs(lv.x)),
                dragTop.Evaluate(Mathf.Abs(lv.y)), dragBottom.Evaluate(Mathf.Abs(lv.y)),
                dragForward.Evaluate(Mathf.Abs(lv.z)) + airbrakeDrag + flapsDrag,   //include extra drag for forward coefficient
                dragBack.Evaluate(Mathf.Abs(lv.z))
            );

            var drag = coefficient.magnitude * lv2 * -lv.normalized;    //drag is opposite direction of velocity

            Rigidbody.AddRelativeForce(drag);
        }

        void UpdateAngularDrag()
        {
            var av = LocalAngularVelocity;
            var drag = av.sqrMagnitude * -av.normalized;    //squared, opposite direction of angular velocity
            Rigidbody.AddRelativeTorque(Vector3.Scale(drag, angularDrag), ForceMode.Acceleration);  //ignore rigidbody mass
        }

        Vector3 CalculateLift(float angleOfAttack, Vector3 rightAxis, float liftPower, AnimationCurve aoaCurve, AnimationCurve inducedDragCurve)
        {
            var liftVelocity = Vector3.ProjectOnPlane(LocalVelocity, rightAxis);    //project velocity onto YZ plane
            var v2 = liftVelocity.sqrMagnitude;                                     //square of velocity

            //lift = velocity^2 * coefficient * liftPower
            //coefficient varies with AOA
            var liftCoefficient = aoaCurve.Evaluate(angleOfAttack * Mathf.Rad2Deg);
            var liftForce = v2 * liftCoefficient * liftPower;

            //lift is perpendicular to velocity
            var liftDirection = Vector3.Cross(liftVelocity.normalized, rightAxis);
            var lift = liftDirection * liftForce;

            //induced drag varies with square of lift coefficient
            var dragForce = liftCoefficient * liftCoefficient;
            var dragDirection = -liftVelocity.normalized;
            var inducedDrag = dragDirection * v2 * dragForce * this.inducedDrag * inducedDragCurve.Evaluate(Mathf.Max(0, LocalVelocity.z));

            return lift + inducedDrag;
        }

        void UpdateLift()
        {
            if (LocalVelocity.sqrMagnitude < 1f) return;

            float flapsLiftPower = flapsDeployed ? this.flapsLiftPower : 0;
            float flapsAOABias = flapsDeployed ? this.flapsAOABias : 0;

            var liftForce = CalculateLift(
                AngleOfAttack + (flapsAOABias * Mathf.Deg2Rad), Vector3.right,
                liftPower + flapsLiftPower,
                liftAOACurve,
                inducedDragCurve
            );

            var yawForce = CalculateLift(AngleOfAttackYaw, Vector3.up, rudderPower, rudderAOACurve, rudderInducedDragCurve);

            Rigidbody.AddRelativeForce(liftForce);
            Rigidbody.AddRelativeForce(yawForce);
        }
        void UpdateThrust()
        {
            Rigidbody.AddRelativeForce(Vector3.forward * (maximumThrust * Throttle) * forceMult, ForceMode.Force);
        }
        float CalculateSteering(float dt, float angularVelocity, float targetVelocity, float acceleration)
        {
            var error = targetVelocity - angularVelocity;
            var accel = acceleration * dt;
            return Mathf.Clamp(error, -accel, accel);
        }

        void UpdateSteering(float dt)
        {
            var controlInput = new Vector3(pitch, yaw, roll);

            var speed = Mathf.Max(0, LocalVelocity.z);
            var steeringPower = steeringCurve.Evaluate(speed);

            var gForceScaling = CalculateGLimiter(controlInput, turnSpeed * Mathf.Deg2Rad * steeringPower);

            var targetAV = Vector3.Scale(controlInput, new Vector3(turnSpeed.x, turnSpeed.y, -turnSpeed.z) * steeringPower * gForceScaling);
            var av = LocalAngularVelocity * Mathf.Rad2Deg;

            var correction = new Vector3(
                CalculateSteering(dt, av.x, targetAV.x, turnAcceleration.x * steeringPower),
                CalculateSteering(dt, av.y, targetAV.y, turnAcceleration.y * steeringPower),
                CalculateSteering(dt, av.z, targetAV.z, turnAcceleration.z * steeringPower)
            );

            Rigidbody.AddRelativeTorque(correction * Mathf.Deg2Rad, ForceMode.VelocityChange);    //ignore rigidbody mass

            var correctionInput = new Vector3(
                Mathf.Clamp((targetAV.x - av.x) / turnAcceleration.x, -1, 1),
                Mathf.Clamp((targetAV.y - av.y) / turnAcceleration.y, -1, 1),
                Mathf.Clamp((targetAV.z - av.z) / turnAcceleration.z, -1, 1)
            );

            var effectiveInput = (correctionInput + controlInput) * gForceScaling;

            EffectiveInput = new Vector3(
                Mathf.Clamp(effectiveInput.x, -1, 1),
                Mathf.Clamp(effectiveInput.y, -1, 1),
                Mathf.Clamp(effectiveInput.z, -1, 1)
            );
        }

        Vector3 CalculateGForce(Vector3 angularVelocity, Vector3 velocity)
        {
            //estiamte G Force from angular velocity and velocity
            //Velocity = AngularVelocity * Radius
            //G = Velocity^2 / R
            //G = (Velocity * AngularVelocity * Radius) / Radius
            //G = Velocity * AngularVelocity
            //G = V cross A
            return Vector3.Cross(angularVelocity, velocity);
        }

        Vector3 CalculateGForceLimit(Vector3 input)
        {
            return Utilities.Scale6(input,
                gLimit, gLimitPitch,    //pitch down, pitch up
                gLimit, gLimit,         //yaw
                gLimit, gLimit          //roll
            ) * 9.81f;
        }

        float CalculateGLimiter(Vector3 controlInput, Vector3 maxAngularVelocity)
        {
            if (controlInput.magnitude < 0.01f)
            {
                return 1;
            }

            //if the player gives input with magnitude less than 1, scale up their input so that magnitude == 1
            var maxInput = controlInput.normalized;

            var limit = CalculateGForceLimit(maxInput);
            var maxGForce = CalculateGForce(Vector3.Scale(maxInput, maxAngularVelocity), LocalVelocity);

            if (maxGForce.magnitude > limit.magnitude)
            {
                //example:
                //maxGForce = 16G, limit = 8G
                //so this is 8 / 16 or 0.5
                return limit.magnitude / maxGForce.magnitude;
            }

            return 1;
        }

        private void Awake()
        {
            rigid = GetComponent<Rigidbody>();

            if (controller == null)
                Debug.LogError(name + ": Plane - Missing reference to MouseFlightController!");
        }

        private void Update()
        {
            // When the player commands their own stick input, it should override what the
            // autopilot is trying to do.
            rollOverride = false;
            pitchOverride = false;

            float keyboardRoll = Input.GetAxis("Horizontal");
            if (Mathf.Abs(keyboardRoll) > .25f)
            {
                rollOverride = true;
            }

            float keyboardPitch = Input.GetAxis("Vertical");
            if (Mathf.Abs(keyboardPitch) > .25f)
            {
                pitchOverride = true;
                rollOverride = true;
            }

            //Calculate the autopilot stick inputs.
            float autoYaw = 0f;
            float autoPitch = 0f;
            float autoRoll = 0f;
            if (controller != null)
                RunAutopilot(controller.MouseAimPos, out autoYaw, out autoPitch, out autoRoll);

            // Use either keyboard or autopilot input.
            yaw = autoYaw;
            pitch = (pitchOverride) ? keyboardPitch : autoPitch;
            roll = (rollOverride) ? keyboardRoll : autoRoll;
        }

        private void RunAutopilot(Vector3 flyTarget, out float yaw, out float pitch, out float roll)
        {
            // This is my usual trick of converting the fly to position to local space.
            // You can derive a lot of information from where the target is relative to self.
            var localFlyTarget = transform.InverseTransformPoint(flyTarget).normalized * sensitivity;
            var angleOffTarget = Vector3.Angle(transform.forward, flyTarget - transform.position);

            // IMPORTANT!
            // These inputs are created proportionally. This means it can be prone to
            // overshooting. The physics in this example are tweaked so that it's not a big
            // issue, but in something with different or more realistic physics this might
            // not be the case. Use of a PID controller for each axis is highly recommended.

            // ====================
            // PITCH AND YAW
            // ====================

            // Yaw/Pitch into the target so as to put it directly in front of the aircraft.
            // A target is directly in front the aircraft if the relative X and Y are both
            // zero. Note this does not handle for the case where the target is directly behind.
            yaw = Mathf.Clamp(localFlyTarget.x, -1f, 1f);
            pitch = -Mathf.Clamp(localFlyTarget.y, -1f, 1f);

            // ====================
            // ROLL
            // ====================

            // Roll is a little special because there are two different roll commands depending
            // on the situation. When the target is off axis, then the plane should roll into it.
            // When the target is directly in front, the plane should fly wings level.

            // An "aggressive roll" is input such that the aircraft rolls into the target so
            // that pitching up (handled above) will put the nose onto the target. This is
            // done by rolling such that the X component of the target's position is zeroed.
            var agressiveRoll = Mathf.Clamp(localFlyTarget.x, -1f, 1f);

            // A "wings level roll" is a roll commands the aircraft to fly wings level.
            // This can be done by zeroing out the Y component of the aircraft's right.
            var wingsLevelRoll = transform.right.y;

            // Blend between auto level and banking into the target.
            var wingsLevelInfluence = Mathf.InverseLerp(0f, aggressiveTurnAngle, angleOffTarget);
            roll = Mathf.Lerp(wingsLevelRoll, agressiveRoll, wingsLevelInfluence);
        }

        private void FixedUpdate()
        {
            float dt = Time.fixedDeltaTime;
            CalculateState();

            UpdateThrust();
            UpdateLift();
            UpdateSteering(dt);

            // Ultra simple flight where the plane just gets pushed forward and manipulated
            // with torques to turn.
            //rigid.AddRelativeTorque(new Vector3(turnTorque.x * pitch,
            //                                    turnTorque.y * yaw,
            //                                    -turnTorque.z * roll) * forceMult,
            //                        ForceMode.Force);

            UpdateDrag();
            UpdateAngularDrag();
        }
    }
}
